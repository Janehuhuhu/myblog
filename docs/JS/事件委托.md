#### 1.事件委托
##### (1) 支持为同一个DOM元素注册多个同类型事件

```js
// 只打印第二次
<div id="div1"></div>

window.onload = function () {
    let div1 = document.getElementById('div1');
    div1.onclick = function () {
        console.log('打印第一次')
    }
    div1.onclick = function () {
        console.log('打印第二次')
    }
}
---------------------------------------------------------------
// 两次都打印
<div id="div1"></div>

window.onload = function () {
    let div1 = document.getElementById('div1');
    div1.addEventListener('click', function () {
        console.log('打印第一次')
    })
    div1.addEventListener('click', function () {
        console.log('打印第二次')
    })
}
```
##### (2) 可将事件分成事件捕获和事件冒泡机制
a. 当一个事件触发后,从Window对象触发,不断经过下级节点,直到目标节点。在事件到达目标节点之前的过程就是捕获阶段。所有经过的节点,都会触发对应的事件。

```js
//当useCapture为默认false时,为事件冒泡
<body>
    <div id="div1"></div>
</body>

window.onload = function () {
    let body = document.querySelector('body');
    let div1 = document.getElementById('div1');
    body.addEventListener('click', function () {
        console.log('打印body')
    })
    div1.addEventListener('click', function () {
        console.log('打印div1')
    })
}

//结果:打印div1  打印body
```
b. 当事件到达目标节点后，会沿着捕获阶段的路线原路返回。同样，所有经过的节点,都会触发对应的事件。

```js
//当useCapture为true时,为事件捕获
<body>
    <div id="div1"></div>
</body>

window.onload = function () {
    let body = document.querySelector('body');
    let div1 = document.getElementById('div1');
    body.addEventListener('click', function(){
        console.log('打印body')
    }, true)
    div1.addEventListener('click', function () {
        console.log('打印div1')
    })  // 该处可不添加true
}

//结果:打印body   打印div1
```
##### (3) 使用事件委托可以自动绑定动态添加的元素;只需添加一个事件处理程序代理所有事件,所占用的内存空间更少。

```js
<body>
    <div id="div">
        <div class="div1">div1</div>
        <div class="div2">div2</div>
    </div>
</body>

window.onload = function () {
    let div = document.getElementById('div');
    div.addEventListener('click', function (e) {
        console.log(e.target);
    })
    let div3 = document.createElement('div');
    div3.setAttribute('class', 'div3')
    div3.innerHTML = 'div3';
    div.appendChild(div3);
}
```
#### 2. 元素排序
   先转换成数组再排序，appendChild 是将元素从父级中删除再插入到新的父级元素中，所以可用于元素的排序。

```js
  <ul id='oUl'>
    <li>2</li>
    <li>4</li>
    <li>1</li>
    <li>0</li>
    <li>5</li>
  </ul>
  <script>
    var aLi = [].slice.call(oUl.children);
    aLi.sort(function (a, b) {
      return a.innerHTML - b.innerHTML;
    });
    for (let i of aLi) {
      oUl.appendChild(i);
    }
  </script>
```
#### 3. 3d盒子和shadow
##### （1）3d盒子
transform属性从后向前执行；先布局，再旋转。X,Y面旋转需要在该对象运动前后加perspective属性，使其有3d效果；z面运动（translateZ）需要在父级元素添加
transform-style:preserve-3d;
<p align='center'>
    <image src='https://github.com/Janehuhuhu/study/blob/master/JS/images/14.gif' width='400px' height='300px'>
</p>

```js
<style type="text/css">
    * {margin: 0;padding:0;list-style: none;}
    #div1 {width: 200px;height: 200px;background: rgba(0,0,0,0);float: left;
        position: absolute;left: 50%;top: 50%;margin: -100px 0 0 -100px;
        transform:perspective(800px) rotateX(-80deg);
        transform-style:preserve-3d;
    }
    #div1 > div {width: 100%;height: 100%;position: absolute;
        transition:1s;
    }
    #front {
        transform:translateZ(100px);
        background: yellow;
    }
    #after {
        transform:translateZ(-100px);background: red;
    }
    #left {
        transform:rotateY(90deg) translateZ(-100px) ;background: green;
    }
    #right {
        transform:rotateY(-90deg) translateZ(-100px) ;background: blue;
    }
    #topNode {
        transform:rotateX(90deg) translateZ(-100px) ;background: pink;
    }
    #bottom {
        transform:rotateX(-90deg) translateZ(-100px) ;background: orange;
    }
</style>

<div id='div1'>
	<div id='front'></div>
	<div id='after'></div>
	<div id='left'></div>
	<div id='right'></div>
	<div id='topNode'></div>
	<div id='bottom'></div>
</div>

<script type="text/javascript">
// 旋转
	var allDiv = div1.children;
	var reg = 0;
	setInterval (function () {
		reg++;
		div1.style.transform = 'perspective(800px) rotateX(' + (reg * 0.3) + 'deg) rotateY(' + 
		(reg*0.2) + 'deg)';
	}, 8);

// 变色
	setInterval(function () {
		for(var i = 0; i < allDiv.length; i++){
			allDiv[i].style.background = 'rgb(' + parseInt(Math.random() * 256) + ',' + parseInt(Math.random() 
			* 256) + ',' + parseInt(Math.random() * 256) + ')';
		}
	}, 1000);
</script>
```
##### (2) text-shadow 文字逐渐清晰
通过修改文字的text-shadow属性，将原文字的透明度变为零，变清晰后的文字实际是阴影，而非原文字。
<p align='center'>
    <image src='https://github.com/Janehuhuhu/study/blob/master/JS/images/15.gif' width='400px' height='300px'>
</p>
    
```js
<style type="text/css">
    * {margin: 0;padding: 0;list-style: none}
    div {width: 200px;height: 200px;
            position: absolute;left: 0;top: 0;bottom: 0;right: 0;margin: auto;border: 1px solid black;
            font-size: 30px;
            text-align: center;
            line-height: 200px;
            text-shadow:0px 0px 100px black;
            color: rgba(0,0,0,0);
            transition:1s;
    }
    div:hover {
        text-shadow:0px 0px 0px black;
    }
</style> 
```
##### (3) box-shadow 太阳阴影效应
通过鼠标位置和屏幕宽度的比例关系设置box-shadow的水平和垂直阴影位置。
<p align='center'>
    <image src='https://github.com/Janehuhuhu/study/blob/master/JS/images/16.gif' width='400px' height='300px'>
</p>
    
```js
<style type="text/css">
    * {margin: 0;padding: 0;list-style: none}
    div {width: 200px;height: 200px;
         position: absolute;left: 0;top: 0;bottom: 0;right: 0;margin: auto;
             border: 1px solid black;box-shadow:30px -30px 10px 0px black;
    }
</style> 

<script type="text/javascript">
	max = 30;
	document.onmousemove = function (e) {
		var ev = e || event;
		var needX = ev.clientX / innerWidth * -60 + 30;
		var needY = ev.clientY / innerHeight * -60 + 30;
		div1.style.boxShadow = needX + 'px ' + needY + 'px 10px 0px black';
	}
</script>
```

