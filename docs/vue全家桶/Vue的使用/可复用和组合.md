## VCA
### 简介
将同一个逻辑关注点相关代码收集在一起，对于组织大型项目代码会非常友好。通过 `VCA` 这种方式可以进行代码的复用 [VCA扫盲](https://juejin.cn/post/6850418114111537159)
<div style='margin-top: 50px'></div>

### 用法
可以看到，写出来的就像一个函数似的，然后在组件中调用
```js
// src/composables/useUserRepositories.js
import { fetchUserRepositories } from '@/api/repositories'
import { ref, onMounted, watch } from 'vue'

export default function useUserRepositories(user) {
  const repositories = ref([])
  const getUserRepositories = async () => {
    repositories.value = await fetchUserRepositories(user.value)
  }

  onMounted(getUserRepositories)
  watch(user, getUserRepositories)

  return {
    repositories,
    getUserRepositories
  }
}
```
```js
// src/components/UserRepositories.vue
import { toRefs } from 'vue'
import useUserRepositories from '@/composables/useUserRepositories'
import useRepositoryNameSearch from '@/composables/useRepositoryNameSearch'
import useRepositoryFilters from '@/composables/useRepositoryFilters'

export default {
  components: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList },
  props: {
    user: {
      type: String,
      required: true
    }
  },
  setup(props) {
    const { user } = toRefs(props)

    const { repositories, getUserRepositories } = useUserRepositories(user)

    const {
      searchQuery,
      repositoriesMatchingSearchQuery
    } = useRepositoryNameSearch(repositories)

    const {
      filters,
      updateFilters,
      filteredRepositories
    } = useRepositoryFilters(repositoriesMatchingSearchQuery)

    return {
      // 因为我们并不关心未经过滤的仓库
      // 我们可以在 `repositories` 名称下暴露过滤后的结果
      repositories: filteredRepositories,
      getUserRepositories,
      searchQuery,
      filters,
      updateFilters
    }
  }
}
```
<div style='margin-top: 50px'></div>


## 函数式组件
### 简介
函数式组件是自身没有任何状态的组件的另一种形式。它们在渲染过程中不会创建组件实例，并跳过常规的组件生命周期。可以把函数式组件想像成组件里的一个函数，入参是渲染上下文(render context)，返回值是渲染好的 `HTML`[函数式组件扫盲](https://v3.cn.vuejs.org/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6)
<div style='margin-top: 50px'></div>

### 用法
[其他用法](https://v3.cn.vuejs.org/guide/migration/functional-components.html#%E6%A6%82%E8%A7%88)
```js
// Vue 2 函数式组件示例 xxx.js
export default {
  functional: true,
  props: ['level'],
  methods: {
  }
  render(h, { props, data, children }) {
    return h(`h${props.level}`, data, children)
  }
}
```
举个例子
```js
// app.vue
<template>
  <FunctionalButton @click="log">
    Click me
  </FunctionalButton>
</template>
```
```js
// FunctionalButton.js
export default {
  functional: true,
  render(createElement, { props, listeners, children }) {
    return createElement(
      'button',
      {
        attrs: props,
        on: {
          click: listeners.click
        }
      },
      children
    );
  }
};
```
<div style='margin-top: 50px'></div>


## 渲染函数 & JSX
### 简介
用 `js` 的方式来渲染 `html` 文件，[详情](https://v3.cn.vuejs.org/guide/render-function.html#dom-%E6%A0%91)
<div style='margin-top: 50px'></div>

### 用法
```js
// 模版文件
<anchored-heading :level="1"> <span>Hello</span> world! </anchored-heading>
```
```js
h(
  'anchored-heading',
  {
    level: 1
  },
  {
    default: () => [h('span', 'Hello'), ' world!']
  }
)
```
上述模板如此简单的情况下，渲染函数写起来比较痛苦，期望能有更接近模版的渲染写法
```js
import AnchoredHeading from './AnchoredHeading.vue'

const app = createApp({
  render() {
    return (
      <AnchoredHeading level={1}>
        <span>Hello</span> world!
      </AnchoredHeading>
    )
  }
})
app.mount('#demo')
```
<div style='margin-top: 50px'></div>

## mixin
### 简介
`Mixin` 提供了一种非常灵活的方式，来分发 `Vue` 组件中的可复用功能。一个 `mixin` 对象可以包含任意组件选项。当组件使用 `mixin` 对象时，所有 `mixin` 对象的选项将被“混合”进入该组件本身的选项。[详情](https://v3.cn.vuejs.org/guide/mixins.html#%E5%9F%BA%E7%A1%80)
<div style='margin-top: 50px'></div>

### 用法
```js
// define a mixin object
const myMixin = {
  created() {
    this.hello()
  },
  methods: {
    hello() {
      console.log('hello from mixin!')
    }
  }
}

// define an app that uses this mixin
const app = Vue.createApp({
  mixins: [myMixin]
})

app.mount('#mixins-basic') // => "hello from mixin!"
```
<div style='margin-top: 50px'></div>

### 问题
- 渲染上下文中暴露的 `property` 来源不清晰。例如在阅读一个运用了多个 `mixin` 的模板时，很难看出某个 `property` 是从哪一个 `mixin` 中注入的。
- 命名空间冲突：`Mixin` 之间的 `property` 和方法可能有冲突，同时高阶组件也可能和预期的 `prop` 有命名冲突。

## vue-hooks
### 简介
`Hooks` 实现了 `mixins` 的功能，但避免了 `mixins` 带来的两个主要问题：
- 允许相互传递状态
- 明确指出逻辑来自哪里
- 避免产生冲突
<br>感觉和`VCA` 的目标是一样的，像是一个试验性的方案，没有找到这两个直接的概念区别，暂时理解为 `VCA`，
<div style='margin-top: 50px'></div>

### 用法
[用法示例](https://juejin.cn/post/6844903784598994952)
<div style='margin-top: 50px'></div>