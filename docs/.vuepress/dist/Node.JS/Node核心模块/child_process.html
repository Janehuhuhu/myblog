<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>child_process - 子进程 | 小生天地</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/logo.jpeg">
    <meta name="description" content="小生学习天地">
    
    <link rel="preload" href="/assets/css/0.styles.c8e23b86.css" as="style"><link rel="preload" href="/assets/js/app.1e0ff288.js" as="script"><link rel="preload" href="/assets/js/2.4ba73d99.js" as="script"><link rel="preload" href="/assets/js/6.c6e1ffb9.js" as="script"><link rel="prefetch" href="/assets/js/10.4eee5e1e.js"><link rel="prefetch" href="/assets/js/11.4b53fc13.js"><link rel="prefetch" href="/assets/js/12.ea4eab51.js"><link rel="prefetch" href="/assets/js/13.0ca26e0e.js"><link rel="prefetch" href="/assets/js/14.f8fdb32b.js"><link rel="prefetch" href="/assets/js/15.5230853a.js"><link rel="prefetch" href="/assets/js/16.19fb2497.js"><link rel="prefetch" href="/assets/js/17.8f34ab93.js"><link rel="prefetch" href="/assets/js/18.28d1b0e2.js"><link rel="prefetch" href="/assets/js/19.f869b4f6.js"><link rel="prefetch" href="/assets/js/20.bffe4966.js"><link rel="prefetch" href="/assets/js/21.9753d22c.js"><link rel="prefetch" href="/assets/js/22.8add9a2a.js"><link rel="prefetch" href="/assets/js/23.05cd7b91.js"><link rel="prefetch" href="/assets/js/24.d1a24eab.js"><link rel="prefetch" href="/assets/js/25.8fa1fc2e.js"><link rel="prefetch" href="/assets/js/26.32596c5a.js"><link rel="prefetch" href="/assets/js/27.bb69b8ee.js"><link rel="prefetch" href="/assets/js/28.9e883e20.js"><link rel="prefetch" href="/assets/js/29.2e1eca56.js"><link rel="prefetch" href="/assets/js/3.2430b9f2.js"><link rel="prefetch" href="/assets/js/30.ff916bfc.js"><link rel="prefetch" href="/assets/js/31.fae75ca0.js"><link rel="prefetch" href="/assets/js/32.ce7ba1fd.js"><link rel="prefetch" href="/assets/js/33.9ff8f1b7.js"><link rel="prefetch" href="/assets/js/34.c16fa8dc.js"><link rel="prefetch" href="/assets/js/35.ebfc43d9.js"><link rel="prefetch" href="/assets/js/36.23861774.js"><link rel="prefetch" href="/assets/js/37.a3c42893.js"><link rel="prefetch" href="/assets/js/38.c941de02.js"><link rel="prefetch" href="/assets/js/39.9ef69f92.js"><link rel="prefetch" href="/assets/js/4.82f14cf4.js"><link rel="prefetch" href="/assets/js/40.372d7734.js"><link rel="prefetch" href="/assets/js/41.b15d16ff.js"><link rel="prefetch" href="/assets/js/42.1dcb925d.js"><link rel="prefetch" href="/assets/js/43.e72f6cb3.js"><link rel="prefetch" href="/assets/js/44.38e7cbe6.js"><link rel="prefetch" href="/assets/js/45.9fc95b3b.js"><link rel="prefetch" href="/assets/js/46.76c3fd6f.js"><link rel="prefetch" href="/assets/js/47.56e198d2.js"><link rel="prefetch" href="/assets/js/48.22c19d1e.js"><link rel="prefetch" href="/assets/js/5.70bf09b3.js"><link rel="prefetch" href="/assets/js/7.d87bc2c7.js"><link rel="prefetch" href="/assets/js/8.f9aee1c5.js"><link rel="prefetch" href="/assets/js/9.b8ff7e4d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c8e23b86.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.jpeg" alt="小生天地" class="logo"> <span class="site-name can-hide">小生天地</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/dwanda" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/dwanda" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Nginx</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/专题/Nginx/安装部署.html" class="sidebar-link">安装部署</a></li><li><a href="/专题/Nginx/常用nginx命令.html" class="sidebar-link">常用nginx命令</a></li><li><a href="/专题/Nginx/配置文件详解.html" class="sidebar-link">配置文件详解</a></li><li><a href="/专题/Nginx/默认网站.html" class="sidebar-link">默认网站</a></li><li><a href="/专题/Nginx/虚拟主机.html" class="sidebar-link">虚拟主机</a></li><li><a href="/专题/Nginx/反向代理.html" class="sidebar-link">反向代理</a></li><li><a href="/专题/Nginx/下载限速.html" class="sidebar-link">下载限速</a></li><li><a href="/专题/Nginx/URL重写.html" class="sidebar-link">URL重写</a></li><li><a href="/专题/Nginx/Nginx优化.html" class="sidebar-link">Nginx优化</a></li><li><a href="/专题/Nginx/Nginx缓存.html" class="sidebar-link">Nginx缓存</a></li><li><a href="/专题/Nginx/Nginx镜像服务器.html" class="sidebar-link">Nginx缓镜像服务器</a></li><li><a href="/专题/Nginx/Nginx集群.html" class="sidebar-link">Nginx集群</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML &amp; CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>npm</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>GIT</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="child-process-子进程"><a href="#child-process-子进程" class="header-anchor">#</a> child_process - 子进程</h2> <p><code>Node.js</code> 中在单进程中单线程，非阻塞的性能非常好。但是，一个 CPU 一个进程不足以处理程序中日益增加的工作负载。无论你的服务器多么强大，一个线程只能支持有限的负载。事实上，Node.js 运行在一个单线程里面并不意味着我们不能利用多进程的优势，当然还有多机器。
  我们可以使用 <code>Node.js</code> 的 <code>child_process</code> 模块很容易地衍生一个子进程，并且那些父子进程使用一个消息系统相互之间可以很容易地交流。我们可以控制子进程的输入流，并且监听它的输出流。我们也可以控制传递给潜在的操作系统命令的参数，我们可以通过那个命令的输出做我们想做的事情。比如：可以将一个命令的输出作为另一个的输入（就像我们在 Linux 做的那样），因为那些命令的输入和输出都是使用流的形式呈现给我们。</p> <h3 id="spawn"><a href="#spawn" class="header-anchor">#</a> spawn</h3> <h4 id="基本用法"><a href="#基本用法" class="header-anchor">#</a> 基本用法</h4> <p>  spawn方法创建一个子进程来执行特定命令，用法与<code>execFile</code>方法类似，但是没有回调函数，只能通过监听事件，来获取运行结果。它属于异步执行，适用于子进程长时间运行的情况。</p> <div class="language-js extra-class"><pre class="language-js"><code>child_process<span class="token punctuation">.</span><span class="token function">spawn</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token punctuation">[</span>args<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>示例，运行 <code>find . -type f</code>，并捕获 <code>stdout</code>、 <code>stderr</code>、以及退出码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> spawn <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'child_process'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token string">'find'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token string">'-type'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

child<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">stdout: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>data<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

child<span class="token punctuation">.</span>stderr<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">stderr: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>data<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

child<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">code</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">子进程退出，退出码 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>code<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="主要参数"><a href="#主要参数" class="header-anchor">#</a> 主要参数</h4> <p><a href="#spawn命令实现shell语句和其他主要参数">主要参数</a><br> <a href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options">其他参数</a></p> <h4 id="事件"><a href="#事件" class="header-anchor">#</a> 事件</h4> <ul><li>exit<br>
当子进程结束后时会触发 <code>exit</code> 事件。 如果进程退出，则 <code>code</code> 是进程的最终退出码，否则为 <code>null</code>。 如果进程是因为收到的信号而终止，则 <code>signal</code> 是信号的字符串名称，否则为 <code>null</code>（正常退出）。 这两个值至少有一个是非 <code>null</code> 的。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>child<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'exit'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">code<span class="token punctuation">,</span> signal</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child process exited with'</span> <span class="token operator">+</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">code </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>code<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> and signal {signal}</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>close<br>
当子进程的 <code>stdio</code> 流已被关闭时会触发 <code>close</code> 事件。 这与 <code>exit</code> 事件不同，因为多个进程可能共享相同的 stdio 流。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>child<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">code<span class="token punctuation">,</span> signal</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child process closed with'</span> <span class="token operator">+</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">code </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>code<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> and signal {signal}</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><p>error<br>
每当出现以下情况时触发 <code>error</code> 事件：
无法衍生进程；
无法杀死进程；
向子进程发送消息失败。
发生错误后，可能会也可能不会触发 <code>exit</code> 事件。 当同时监听 <code>exit</code> 和 <code>error</code> 事件时，则需要防止意外地多次调用处理函数。</p></li> <li><p>message<br>
当子进程使用 <code>process.send()</code> 函数发送信息的时候，<code>message</code> 事件会被触发。</p></li></ul> <h4 id="流"><a href="#流" class="header-anchor">#</a> 流</h4> <p>  每一个子进程都会得到三个标准的输入输出流，我们可以通过 <code>child.stdin</code>，<code>child.stdout</code> 和 <code>child.stderr</code> 进入。
  所有的流都是事件发射器，我们可以在那些被绑定到每一个子进程的 <code>stdio</code> 流监听不同的事件。不像在一个正常的进程中，在子进程中，<code>stdout/stderr</code> 流是可读的流，而 <code>stdin</code> 是可写的流。基本上是主进程中相反类型的。可以在这些流上使用的事件是标准的。更重要的是，在可读流上，我们可以监听 <code>data</code> 事件，可以得到命令的输出和在执行命令时遇到的错误：</p> <div class="language-js extra-class"><pre class="language-js"><code>child<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">child stdout: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>data<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
child<span class="token punctuation">.</span>stderr<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">stderror </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>data<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre></div><p>  一个子进程 <code>stdin</code> 是一个可写的流。我们可以用它发送一个命令的输入。像任何一个可写流那样，最简单消费它的方式时使用 <code>pipe</code> 函数。我们简单地将一个可读流 <code>pipe</code> 到另一个可写流里。因为主进程的 <code>stdin</code> 是可读流，我们可以将它 <code>pipe</code> 到子进程的 <code>stdin</code> 流里。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span>spawn<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'child_process'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token string">'wc'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>stdin<span class="token punctuation">)</span><span class="token punctuation">;</span>
child<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">child stdout: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>data<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在上面的例子中，子进程执行了 <code>wc</code> 命令，是一个计算行数，单词数，和字母数的Linux 命令。我们可以将主进程的 <code>stdin</code>（是可读流）<code>pipe</code> 到子进程的 <code>stdin</code>（是一个可读流）。结合的结果是我们得到了一个标准的输入模式，我们可以输入一些东西，当 <code>CTRL+ D</code> 时，我们输入的将会被用来作为 <code>wc</code> 命令的参数。
  我们也可以在多进程标准输入输出之间相互 pipe，就像我们用 Linux 命令做的那样。例如：我们可以 <code>pipe</code> <code>find</code> 命令的 <code>stdout</code> 到 <code>wc</code>（在当前目录中统计所有的文件） 命令的 <code>stdin</code> 里。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span>spawn<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'child_process'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> find <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token string">'find'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token string">'-type'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> wc <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token string">'wc'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'-l'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
find<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>wc<span class="token punctuation">.</span>stdin<span class="token punctuation">)</span><span class="token punctuation">;</span>
wc<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Number of files </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>data<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="exec"><a href="#exec" class="header-anchor">#</a> exec</h3> <h4 id="基本用法-2"><a href="#基本用法-2" class="header-anchor">#</a> 基本用法</h4> <p>  默认地，<code>spawn</code> 函数并没有创建一个 <code>shell</code> 去执行我们传入地命令。这使得它比 <code>exec</code> 函数执行稍微高效一点儿，<code>exec</code> 创建了个 <code>shell</code>。<code>exec</code> 函数有另一个主要地区别：将命令的输出放到缓冲区，并且将整个输出值传递给一个回调（而不是像 <code>spawn</code> 那样使用流）。</p> <div class="language-js extra-class"><pre class="language-js"><code>child_process<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
</code></pre></div><p>用 <code>exec</code> 函数实现之前的示例，因为 <code>exec</code> 函数会使用 <code>shell</code>去执行命令，因此我们可以直接使用 <code>shell</code> 语法代替 <code>pipe</code> 特性。exec 函数将输出放入缓存区，并且将它作为 stdout 传递给回调函数（exec 函数的第二个参数）。stdout 是我们想要打印的命令的输出。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> exec <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'child_process'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'find . -type f | wc -l'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> stdout<span class="token punctuation">,</span> stderr</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">exec error: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>err<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Number of files </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>stdout<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="适用范围"><a href="#适用范围" class="header-anchor">#</a> 适用范围</h4> <p>如果你想要使用 shell 语法并且运行命令输出的所期望的数据比较小，建议使用 exec 函数（记住，exec 在返回结果数据之前，会在内存中缓存整个数据）。如果期望的数据很大，那么建议使用 spawn 函数，因为数据可以被标准的 IO 对象流化（streamed）。</p> <h4 id="注意事项"><a href="#注意事项" class="header-anchor">#</a> 注意事项</h4> <p>如果你执行外部提供的任何类型的动态输入，使用 shell 语法是有安全风险的。用户使用 像 ；的shell 语法字符和 $ 来进行命令注入攻击（例如：command + <code>; rm -rf ~</code>）。</p> <h4 id="spawn命令实现shell语句和其他主要参数"><a href="#spawn命令实现shell语句和其他主要参数" class="header-anchor">#</a> spawn命令实现shell语句和其他主要参数</h4> <ul><li>spawn命令实现shell语句<br>
可以使用 <code>spawn</code> 函数使用 <code>shell</code> 语法。下面是 <code>find | wc</code> 命令的 <code>spawn</code> 的实现版本：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token string">'find . -type f | wc -l'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    stdio<span class="token operator">:</span> <span class="token string">'inherit'</span><span class="token punctuation">,</span>
    shell<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>因为上面的 <code>stdio: 'inherit'</code> 的配置选项，当我们执行代码的时候，子进程将会继承主进程的 <code>stdin，stdout，stderr</code>。这回导致子进程数据事件处理器在主进程的 <code>process.stdout</code> 流中被触发，让脚本有正确的输出方式。因为上面的 <code>shell: true</code> 的配置选项，我们可以在传递的命令中使用 <code>shell</code> 语法，就像我们在 <code>exec</code> 函数中做的那样。但是用这段代码，我们仍能利用 <code>spawn</code> 函数输出的数据的流的特性。</p> <ul><li>cwd<br>
通过 <code>cwd</code> 选项更改脚本的工作目录。统计 ~/Downloads 文件夹下所有的文件的统计信息：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token string">'find . -type f | wc -l'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    stdio<span class="token operator">:</span> <span class="token string">'inherit'</span><span class="token punctuation">,</span>
    shell<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    cwd<span class="token operator">:</span> <span class="token string">'/Uers/samer/Downloads'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>env<br>
指定子进程的环境变量。默认的是 <code>process.env</code>，给了子进程一个命令可以进入父 <code>process</code> 环境。如果我们想覆盖这个默认行为，可以给 <code>env</code> 选项一个空对象，或者给一个对象作为子进程唯一的环境变量。如下面的命令不能获取父进程的环境变量。比如：不能获取 <code>$HOME</code>，但是可以获取 <code>$ANSWER</code> ，因为是通过 <code>env</code> 选项配置的，作为子进程的局部环境变量。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token string">'echo $ANSWER'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    stdio<span class="token operator">:</span> <span class="token string">'inherit'</span><span class="token punctuation">,</span>
    shell<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    end<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token constant">ANSWER</span><span class="token operator">:</span> <span class="token number">42</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>detached<br>
使子进程独立于它的父进程运行。假设我们有一个文件 timer.js，可以是时间循环忙碌：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  
<span class="token comment">// keep the event loop busy</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们可以使用 detached 选项在后台执行它：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> spawn <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'child_process'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token string">'node'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'timer.js'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    detached<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    stdio<span class="token operator">:</span> <span class="token string">'ignore'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
child<span class="token punctuation">.</span><span class="token function">unref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>子进程 <code>detached</code> 后的行为取决于操作系统。在 <code>windows</code> 上面，解绑后（detached）的子进程有它们自己的window 控制台。然而，在 <code>Linux</code> 上面，解绑后（detached）的子进程将会领导一个新的进程组和 <code>session</code>。如果在解绑的进程上面调用 <code>unref</code> 函数，父进程可以独立于子进程退出(默认情况下，父进程将会等待被分离的子进程退出。 为了防止父进程等待 <code>subprocess</code>，可以使用 <code>subprocess.unref()</code> 方法)。如果子进程在运行一个长时间的任务，这将非常有用，但是在后台保持运行，否则子进程的配置也不得不独立于父进程之外。</p> <h3 id="execfile"><a href="#execfile" class="header-anchor">#</a> execFile</h3> <h4 id="基本用法-3"><a href="#基本用法-3" class="header-anchor">#</a> 基本用法</h4> <p><code>execFile</code>方法直接执行特定的程序，参数作为数组传入，不会被<code>bash</code>解释，因此具有较高的安全性。它表现的和 <code>exec</code> 函数一样，但是不用 <code>shell</code>，这让它更高效一点儿。在 <code>windows</code> 上面，一些文件如 <code>.bat</code> 和 <code>.cmd</code> 凭它们自己不能被执行，这些文件不能被 <code>execFile</code> 执行，执行它们 需要 <code>exec</code> 或者将 <code>shell</code> 设置为 <code>true</code> 的 <code>spawn</code> 函数。</p> <div class="language-js extra-class"><pre class="language-js"><code>child_process<span class="token punctuation">.</span><span class="token function">execFile</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span><span class="token punctuation">[</span>args<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
</code></pre></div><h3 id="fork"><a href="#fork" class="header-anchor">#</a> fork</h3> <h4 id="基本用法-4"><a href="#基本用法-4" class="header-anchor">#</a> 基本用法</h4> <p><code>fork</code> 函数是 <code>spawn</code> 函数的另一种衍生（fork） <code>node</code> 进程的形式。</p> <div class="language-js extra-class"><pre class="language-js"><code>child_process<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span>modulePath<span class="token punctuation">,</span><span class="token punctuation">[</span>args<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="主要特点"><a href="#主要特点" class="header-anchor">#</a> 主要特点</h4> <p><code>spawn</code> 和 <code>fork</code> 之间最大的不同是当使用 <code>fork</code> 函数时，到子进程的通信通道被建立了，因此我们可以在子进程里通过全局的 <code>process</code> 使用 <code>send</code>函数，在父子进程之间交换信息。如例1：<br>
parent.js</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span>fork<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'child_process'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> forked <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token string">'child.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
forked<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'messsgae from child'</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
forked<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">{</span>hello<span class="token operator">:</span> <span class="token string">'world'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>child.js</p> <div class="language-js extra-class"><pre class="language-js"><code>process<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'message from parent:'</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> conter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    process<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">{</span>counter<span class="token operator">:</span> counter<span class="token operator">++</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在上面的 <code>parent.js</code> 里面，我们衍生（fork）了 <code>child.js</code> 文件（将会被 <code>node</code> 命令执行），然后监听了 <code>message</code> 事件。当子进程使用 <code>process.send</code> 的时候，<code>message</code> 事件就会被触发。当执行 <code>parent.js</code> 的时候，它会首先发送一个对象 {hello: 'world'}。在 <code>child.js</code> 中，每秒中向父进程发送一个增加的数。<br></p> <p>例2: 假设我们有一个 <code>http</code> 服务器要处理两端。其中一端（/compute）计算比较多，将会花费几秒钟才能完成。我们可以用一个长循环来模拟：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">longComputation</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">1e9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'request'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/compute'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> sum <span class="token operator">=</span> <span class="token function">longComputation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Sum is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>sum<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Ok'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这个程序有一个很大的问题，当请求 <code>/compute</code> 时，服务器将不能处理其他的请求，因为事件循环在忙于长循环操作。在一个新的 compute.js 文件中：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">longComputation</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> <span class="token number">1e9</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
process<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> sum <span class="token operator">=</span> <span class="token function">longComputation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    process<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>现在，不再是在主进程事件循环中做长循环操作，我们可以衍生（fork） <code>compute.js</code> 文件，然后用通信接口在服务器（主进程）和子进程之间交流。当收到一个 <code>/compute</code> 的请求时，我们发送了一个简单的信息给子进程开始执行长循环。主进程的事件循环不会被阻塞。一旦子进程完成了长循环操作，它会通过 <code>process.send</code> 将结果发送给主进程。在父进程里面，我们在子进程上面监听了 <code>message</code> 事件。当我们得到这个值的时候，我们有了一个 <code>sum</code> 值，然后将它通过 <code>http</code> 发送给用户。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> fork <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'child_process'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'request'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/compute'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> compute <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token string">'compute.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        compute<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        compute<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token parameter">sum</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Sum is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>sum<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'OK'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="sync"><a href="#sync" class="header-anchor">#</a> *sync</h3> <p>从 <code>child_process</code> 模块导出的函数 <code>spawn</code>，<code>exec</code>，<code>execFile</code> 都有同步阻塞的版本，等待直到子进程退出。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> 
spawnSync<span class="token punctuation">,</span> 
execSync<span class="token punctuation">,</span> 
execFileSync<span class="token punctuation">,</span>
<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'child_process'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="第三方包execa"><a href="#第三方包execa" class="header-anchor">#</a> 第三方包execa</h3> <p><a href="https://www.npmjs.com/package/execa" target="_blank" rel="noopener noreferrer">execa npm<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="常见问题"><a href="#常见问题" class="header-anchor">#</a> 常见问题</h3> <ul><li><p>为什么执行execSync会多报出一个错误？<br>
因为 <code>execSync</code> 比 <code>exec</code> 多出一段检查同步执行的错误检查过程，该过程会打印错误。
<img src="/assets/img/1603768508717-image.286915e8.png" alt="execSync"> <img src="/assets/img/1603768542717-image.44551475.png" alt="checkExecSyncError"> <img src="/assets/img/1603768579902-image.a522cebf.png" alt="exec"></p></li> <li><p>stdio的取值间区别？inherit,pipe,ignore？<br> <code>pipe</code> - 在子进程和父进程之间创建一个管道。 管道的父端作为 <code>child_process</code> 对象上的 <code>subprocess.stdio[fd]</code> 属性暴露给父进程。不会打印子进程的输出。<br> <code>inherit</code> - 将相应的 <code>stdio</code> 流传给父进程或从父进程传入。会打印子进程的输出。<br> <code>ignore</code> - 指示 <code>Node.js</code> 忽略子进程中的 <code>fd</code>。</p></li></ul> <h5 id="参考文档"><a href="#参考文档" class="header-anchor">#</a> 参考文档</h5> <ul><li><a href="https://github.com/nodejs/node/blob/v14.14.0/lib/child_process.js" target="_blank" rel="noopener noreferrer">源码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://javascript.ruanyifeng.com/nodejs/child-process.html#toc0" target="_blank" rel="noopener noreferrer">阮一峰 Child Process模块<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://nodejs.cn/api/child_process.html#child_process_child_process" target="_blank" rel="noopener noreferrer">Node.js 中文文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://zhuanlan.zhihu.com/p/36678971" target="_blank" rel="noopener noreferrer">Node.js 子进程：你需要知道的一切<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.1e0ff288.js" defer></script><script src="/assets/js/2.4ba73d99.js" defer></script><script src="/assets/js/6.c6e1ffb9.js" defer></script>
  </body>
</html>
